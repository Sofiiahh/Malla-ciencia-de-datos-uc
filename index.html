<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Malla Estratégica Interactiva — Ciencia de Datos</title>
<style>
  :root{
    --bg:#fbfbfd;
    --card:#ffffff;
    --muted:#666;
    --accent:#2EC4B6;
    --radius:12px;
  }
  *{box-sizing:border-box}
  body{
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    margin:0; background:var(--bg); color:#102027; -webkit-font-smoothing:antialiased;
    padding:16px;
  }
  header.hero{
    text-align:center; margin-bottom:12px; padding:14px;
    background: linear-gradient(90deg, rgba(255,214,231,0.18), rgba(214,255,255,0.14));
    border-radius:16px;
  }
  header.hero h1{margin:0;font-size:20px}
  header.hero p{margin:6px 0 0 0;color:var(--muted); font-size:14px}

  .controls{
    display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap;
    margin:14px 0 18px 0;
  }
  .controls label{font-size:14px; color:var(--muted)}
  .controls .small{font-size:13px;color:var(--muted);display:block;margin-top:6px;text-align:center}

  /* Grid of semesters */
  .grid{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(240px,1fr));
    gap:12px;
    align-items:start;
  }
  .semester{
    background:var(--card); border-radius:var(--radius); padding:10px; box-shadow:0 6px 18px rgba(8,10,15,0.04);
    min-height:120px;
  }
  .semester h3{margin:0 0 8px 0; font-size:15px}
  .courses{display:flex; flex-direction:column; gap:8px}
  .course{
    display:flex; gap:8px; align-items:start; padding:8px; border-radius:10px; border:1px solid #eee; text-align:left;
    background: linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.95));
    cursor:pointer;
  }
  .course .meta{font-size:13px; color:#0b2b2b}
  .course .code{font-weight:700; font-size:13px}
  .course.aprobado{background:linear-gradient(90deg,#2EC4B6,#2EC4B6); color:white; border-color:rgba(46,196,182,0.6)}
  .course.desbloqueado{background:linear-gradient(90deg,#ffdff2,#ffdff2)}
  .course.bloqueado{opacity:0.85; filter:none; pointer-events:auto}

  /* colors for semester backgrounds (pastel) */
  .sem-bg-1{background:linear-gradient(180deg,#fff0ea,#fff7f1)}
  .sem-bg-2{background:linear-gradient(180deg,#fff5f9,#fff9fc)}
  .sem-bg-3{background:linear-gradient(180deg,#f2fff6,#f8fff9)}
  .sem-bg-4{background:linear-gradient(180deg,#f0fbff,#f8fdff)}
  .sem-bg-5{background:linear-gradient(180deg,#faf0ff,#fdf7ff)}
  .sem-bg-6{background:linear-gradient(180deg,#fffdea,#fffef7)}
  .sem-bg-7{background:linear-gradient(180deg,#fff4ea,#fff6f0)}
  .sem-bg-8{background:linear-gradient(180deg,#f7fff0,#fbfff6)}

  /* plans area */
  .plans{margin-top:18px}
  .plans h2{margin:0 0 8px 0; text-align:center}
  .plan-card{background:var(--card); border-radius:12px; padding:12px; margin-bottom:12px; box-shadow:0 6px 18px rgba(8,10,15,0.04)}
  .plan-title{display:flex; align-items:center; justify-content:space-between; gap:8px}
  .plan-grid{display:grid; grid-template-columns:repeat(8,1fr); gap:6px; margin-top:10px}
  .plan-cell{padding:8px;border-radius:8px;border:1px dashed #eee;font-size:12px;text-align:center; min-height:46px}
  .pill{display:inline-block;padding:6px 8px;border-radius:999px;background:#eef;font-size:12px;margin:4px 4px 4px 0}

  /* action plan */
  .action{background: linear-gradient(90deg,#fffdf2,#f7fff6); padding:12px; border-radius:10px}
  ol{margin:8px 0 0 18px}

  .legend{display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; align-items:center; justify-content:center}
  .legend .box{display:flex; gap:6px; align-items:center; font-size:13px; color:var(--muted)}
  .legend .sw{width:18px;height:18px;border-radius:4px;border:1px solid #eee}

  .variant-label{display:inline-block;padding:6px 10px;border-radius:8px;background:#f3f7f6;font-weight:700;margin-left:8px}

  footer.footer{text-align:center;color:var(--muted); margin:18px 0 36px 0; font-size:13px}

  /* responsive */
  @media(max-width:700px){
    .plan-grid{grid-template-columns:repeat(4,1fr)}
    .controls{flex-direction:column;gap:6px;}
  }
</style>
</head>
<body>

<header class="hero">
  <h1>Malla Estratégica Interactiva — Licenciatura en Ciencia de Datos</h1>
  <p>Generador de rutas: compara hasta 3 planes óptimos basados en tu malla real.</p>
</header>

<section class="controls" aria-label="Controles">
  <label>
    Semestre actual:
    <select id="semActual"></select>
  </label>

  <label>
    Rellenar desde semestre:
    <select id="startSemester">
      <option value="">(usar semestre siguiente)</option>
    </select>
    <span class="small">El generador intentará ubicar ramos comenzando desde este número si lo seleccionas.</span>
  </label>

  <div style="text-align:center; width:100%;">
    <div class="legend" aria-hidden="true">
      <div class="box"><span class="sw" style="background:#2EC4B6"></span> Aprobado</div>
      <div class="box"><span class="sw" style="background:#FF9EBB"></span> Desbloqueado</div>
      <div class="box"><span class="sw" style="background:#CCCCCC"></span> Bloqueado</div>
    </div>
  </div>
</section>

<main id="mallaGrid" class="grid" aria-live="polite"></main>

<section class="plans" id="plansArea">
  <h2>Planes recomendados <span class="variant-label">máx. 3 alternativas</span></h2>
  <div id="plansContainer"></div>

  <div class="plan-card action" style="margin-top:10px;">
    <h3 style="margin:0 0 8px 0">Plan de acción para el semestre <span id="semLabel">1</span></h3>
    <ol id="planAction"></ol>
    <p style="margin-top:10px; color:var(--muted)">Marca los ramos aprobados (clic) para que la malla y las rutas se actualicen.</p>
  </div>
</section>

<footer class="footer">Diseñado para generar rutas reales — fuerza y enfoque para tus evaluaciones.</footer>

<script>
/* ===== Datos de la malla (tu malla + prerequisitos) ===== */
const R = {
  IC1103:{nombre:'Introducción a la Programación',sem:1,pr:[]},
  MAT1107:{nombre:'Introducción al Cálculo',sem:1,pr:[]},
  MAT1207:{nombre:'Introducción al Álgebra y Geometría',sem:1,pr:[]},
  MAT0007:{nombre:'Taller de Matemáticas para Estadística',sem:1,pr:[]},
  OFG1:{nombre:'OFG (FIL2001)',sem:1,pr:[]},

  IIC2233:{nombre:'Programación Avanzada',sem:2,pr:['IC1103']},
  MAT1610:{nombre:'Cálculo I',sem:2,pr:['MAT1107']},
  IMT2210:{nombre:'Álgebra Lineal para Ciencia de Datos',sem:2,pr:['IC1103','MAT1107','MAT1207']},
  IMT2200:{nombre:'Introducción a Ciencia de Datos',sem:2,pr:['IC1103','MAT1207']},
  OFG2:{nombre:'OFG (Teológico)',sem:2,pr:[]},

  IMT2220:{nombre:'Cálculo para Ciencia de Datos',sem:3,pr:['MAT1610']},
  IMT2230:{nombre:'Álgebra Lineal Avanzada y Modelamiento',sem:3,pr:['MAT1610','IMT2210']},
  ETI195:{nombre:'Ética para Ciencia de Datos y Estadística',sem:3,pr:['IIC2233','IMT2200']},
  IIC1253:{nombre:'Matemáticas Discretas',sem:3,pr:['IMT2210']},
  OFG3:{nombre:'OFG',sem:3,pr:[]},

  EYP1025:{nombre:'Modelos Probabilísticos',sem:4,pr:['IMT2220','IMT2230']},
  IC2133:{nombre:'Estructuras de Datos y Algoritmos',sem:4,pr:['IIC2233','IIC1253']},
  IC2413:{nombre:'Bases de Datos',sem:4,pr:['IIC2233','IIC1253']},
  IMT2250:{nombre:'Optimización para Ciencia de Datos',sem:4,pr:['IMT2220','IMT2210']},
  OFG4:{nombre:'OFG',sem:4,pr:[]},

  EYP2114:{nombre:'Inferencia Estadística',sem:5,pr:['EYP1025']},
  IIC2613:{nombre:'Inteligencia Artificial',sem:5,pr:['EYP1025','IIC2233']},
  LIC2440:{nombre:'Procesamiento de Datos Masivos',sem:5,pr:['IC2413','IC2133']},
  OFG5:{nombre:'OFG',sem:5,pr:[]},
  OPR5:{nombre:'OPR o Minor',sem:5,pr:[]},

  EYP2101:{nombre:'Procesos Estocásticos Aplicados',sem:6,pr:['EYP2114']},
  EYP2301:{nombre:'Análisis de Regresión',sem:6,pr:['EYP2114']},
  C2026:{nombre:'Visualización de la Información',sem:6,pr:['IC1103']},
  IIC2433:{nombre:'Minería de Datos',sem:6,pr:['IC1103','EYP1025','IMT2210']},
  OFG6:{nombre:'OFG',sem:6,pr:[]},

  EYP2111:{nombre:'Simulación',sem:7,pr:['EYP2101']},
  EYP2801:{nombre:'Métodos Bayesianos',sem:7,pr:['EYP2114']},
  IMT2260:{nombre:'Teoría de Aprendizaje Automático',sem:7,pr:['IMT2250','EYP1025']},
  OFG7:{nombre:'OFG',sem:7,pr:[]},
  OPR7:{nombre:'OPR o Minor',sem:7,pr:[]},

  IMT2270:{nombre:'Proyecto de Graduación',sem:8,pr:['EYP2801','IMT2260','IMT2250','ETI195']},
  OFG8_A:{nombre:'OPR o Minor',sem:8,pr:[]},
  OFG8_B:{nombre:'OPR o Minor',sem:8,pr:[]},
  OFG8_C:{nombre:'OPR o Minor',sem:8,pr:[]},
  OFG8:{nombre:'OFG',sem:8,pr:[]}
};

/* pastel colors for semesters */
const semColors = ['#FFD6E8','#FFD7F0','#C6FFF0','#CDEFF6','#FFE4C4','#FFD1A6','#F5F7A2','#DDEFCB'];

/* UI refs */
const mallaGrid = document.getElementById('mallaGrid');
const semActualSel = document.getElementById('semActual');
const plansContainer = document.getElementById('plansContainer');
const planAction = document.getElementById('planAction');
const semLabel = document.getElementById('semLabel');
const startSemesterSel = document.getElementById('startSemester');

/* state */
let approved = []; // aprobados por el usuario (se marcan con clic)
const MAX_PER_SEM = 6; // absoluto: máximo 6 ramos por semestre
const SEM_OBJETIVO = 8; // intentar siempre 8 semestres
const PLAN_LIMIT = 3; // cuántos planes distintos queremos retornar (hasta 3)

/* Build sem lists for UI display */
const semCourses = {};
for(let s=1;s<=8;s++) semCourses[s] = Object.keys(R).filter(k => R[k].sem === s);

/* fill semActual select */
for(let s=1;s<=8;s++){
  const opt = document.createElement('option'); opt.value = s; opt.textContent = s;
  semActualSel.appendChild(opt);
}
semActualSel.value = '1';

/* fill startSemester select */
for(let s=1;s<=12;s++){
  const o = document.createElement('option'); o.value = s; o.textContent = s;
  startSemesterSel.appendChild(o);
}
startSemesterSel.value = '';

/* Helpers */
function canTake(code, approvedList){
  const prereqs = R[code] && R[code].pr ? R[code].pr : [];
  return prereqs.every(p => approvedList.includes(p));
}
function dependentsCount(code){
  return Object.values(R).reduce((acc,r)=> acc + ((r.pr||[]).includes(code)?1:0),0);
}

/* Render malla (UI) */
function renderMalla(){
  mallaGrid.innerHTML = '';
  for(let s=1;s<=8;s++){
    const box = document.createElement('section');
    box.className = 'semester sem-bg-' + s;
    box.style.background = semColors[s-1];
    const h = document.createElement('h3'); h.textContent = 'Semestre ' + s;
    box.appendChild(h);
    const list = document.createElement('div'); list.className = 'courses';

    semCourses[s].forEach(code => {
      const btn = document.createElement('button');
      btn.className = 'course';
      btn.type = 'button';
      const isApproved = approved.includes(code);
      const unlocked = canTake(code, approved);

      if(isApproved) btn.classList.add('aprobado');
      else if(unlocked) btn.classList.add('desbloqueado');
      else btn.classList.add('bloqueado');

      btn.innerHTML = `<div class="code">${code}</div><div class="meta">${R[code] ? R[code].nombre : ''}</div>`;

      btn.onclick = () => {
        if(approved.includes(code)) approved = approved.filter(x => x !== code);
        else if(canTake(code, approved)) approved.push(code);
        updateAll();
      };

      list.appendChild(btn);
    });

    if(semCourses[s].length === 0){
      const empty = document.createElement('div');
      empty.className = 'course bloqueado';
      empty.textContent = 'Sin ramos en la malla para este semestre.';
      list.appendChild(empty);
    }

    box.appendChild(list);
    mallaGrid.appendChild(box);
  }
}

/* -----------------------
   Ramos anuales: normalizaciones y set
   (correcciones por typos que mencionaste)
*/
const annualCorrections = {
  'EYP280I':'EYP2801',
  'IIC2440':'LIC2440', // usuario puso IIC2440 en vez de LIC2440
  'INT2250':'IMT2250'
};
const userAnnualsRaw = [
  'IIC2440','EYP280I','IMT2260','FIS154D',
  'IMT2200','INT2250'
];
// Normalize and keep only those present in R
const annualCourses = new Set(userAnnualsRaw.map(c=>{
  const corrected = annualCorrections[c] || c;
  return corrected;
}).filter(c => R[c]));
function isAnnual(code){
  return annualCourses.has(code);
}

/* Helper: is free-movable (OFG / OPR / OPR-like) */
function isFreeMovable(code){
  if(!code) return false;
  return code.startsWith('OFG') || code.startsWith('OPR') || code.includes('OPR') || code.includes('MINOR') || code.includes('Minor');
}

/* -----------------------
   GENERACIÓN: Backtracking + heurística -> múltiples planes óptimos distintos
   - Intenta encajar todo en SEM_OBJETIVO semestres
   - Respeta MAX_PER_SEM
   - Solo 1 semestre extra (el 9º) si es necesario
   - Produce hasta PLAN_LIMIT planes distintos
   - Firma del estado incluye sem y lista para evitar colisiones
*/
function generatePlans(initialApproved, limit = PLAN_LIMIT, startSemester = ''){
  const uiStart = Number(semActualSel.value);
  const startSem = startSemester ? Number(startSemester) : (uiStart + 1);
  const span = SEM_OBJETIVO; // 8 sem target
  const maxAllowed = span + 1; // allow one extra (9th)
  const allCourses = Object.keys(R).filter(c => !initialApproved.includes(c));
  const results = [];
  const seen = new Set();

  function planKey(plan){
    return Object.keys(plan).sort((a,b)=>a-b)
      .map(s => `${s}:${(plan[s]||[]).join(',')}`)
      .join('|');
  }

  function assignedSetFromPlan(plan){
    const s = new Set();
    Object.values(plan).flat().forEach(x => {
      const code = String(x).replace(/\s*\(anual\)$/,'');
      s.add(code);
    });
    return s;
  }

  // Check restrictions for placing course at sem
  function canPlaceSingle(plan, course, sem){
    // Respect capacity
    if((plan[sem]||[]).length >= MAX_PER_SEM) return false;
    // Respect natural semester suggestion except for free-movable
    if(!isFreeMovable(course) && R[course] && R[course].sem > sem) return false;
    return true;
  }
  function canPlaceAnnual(plan, course, sem, allowedEnd){
    // annual needs sem and sem+1
    const s1 = sem, s2 = sem+1;
    if(s2 > allowedEnd) return false;
    if((plan[s1]||[]).length >= MAX_PER_SEM) return false;
    if((plan[s2]||[]).length >= MAX_PER_SEM) return false;
    if(!isFreeMovable(course) && R[course] && R[course].sem > sem) return false;
    return true;
  }

  // DFS
  function dfs(sem, approvedSet, planObj, allowedEnd){
    if(results.length >= limit) return;
    // Stop if sem > allowedEnd
    if(sem > allowedEnd){
      // check complete
      const assignedCodes = assignedSetFromPlan(planObj);
      allCourses.forEach(c => {
        // if a course is free-movable, it is still in allCourses list so must be included
      });
      if(assignedCodes.size >= allCourses.length){
        const key = planKey(planObj);
        if(!seen.has(key)){
          seen.add(key);
          results.push(JSON.parse(JSON.stringify(planObj)));
        }
      }
      return;
    }

    // If already assigned all, collect
    const currentAssigned = assignedSetFromPlan(planObj);
    initialApproved.forEach(a => currentAssigned.add(a));
    if(currentAssigned.size >= allCourses.length){
      const key = planKey(planObj);
      if(!seen.has(key)){
        seen.add(key);
        results.push(JSON.parse(JSON.stringify(planObj)));
      }
      return;
    }

    // Build currentAssigned + approvedSet (for prereqs)
    const approvedTotal = new Set(Array.from(approvedSet));
    Array.from(currentAssigned).forEach(x=>approvedTotal.add(x));

    // Candidates: not assigned, prereqs met with approvedTotal, and (R[c].sem <= sem OR free-movable)
    let candidates = allCourses.filter(c => !approvedTotal.has(c) && canTake(c, Array.from(approvedTotal)) && (isFreeMovable(c) || !R[c] || R[c].sem <= sem));
    // Sort by dependents to prefer unlocking
    candidates.sort((a,b)=> dependentsCount(b) - dependentsCount(a) || a.localeCompare(b));

    // If no candidates, skip semester (empty) but still proceed — this allows prereqs to be satisfied by later sems
    if(candidates.length === 0){
      const copyPlan = Object.assign({}, planObj);
      copyPlan[sem] = copyPlan[sem] || [];
      dfs(sem+1, new Set(approvedSet), copyPlan, allowedEnd);
      return;
    }

    // Build variants: greedy and some alternatives
    const variants = [];
    // Greedy fill up to capacity
    (function(){
      const tempAssigned = new Set(approvedTotal);
      const pickList = [];
      for(const c of candidates){
        if(pickList.length >= MAX_PER_SEM) break;
        if(tempAssigned.has(c)) continue;
        if(isAnnual(c)){
          if(!canPlaceAnnual(planObj, c, sem, allowedEnd)) continue;
          pickList.push(c);
          tempAssigned.add(c);
        } else {
          if(!canPlaceSingle(planObj, c, sem)) continue;
          pickList.push(c);
          tempAssigned.add(c);
        }
      }
      if(pickList.length>0) variants.push(pickList);
    })();

    // Top-k slices to create alternatives
    for(let t=1; t<=Math.min(candidates.length, MAX_PER_SEM) && variants.length < 10; t++){
      variants.push(candidates.slice(0,t));
    }

    // Swap-based alternatives
    for(let i=0; i<Math.min(3,candidates.length) && variants.length<15; i++){
      for(let j=3; j<Math.min(candidates.length, 9) && variants.length<15; j++){
        const base = candidates.slice(0, Math.min(MAX_PER_SEM, candidates.length));
        if(base.includes(candidates[j])) continue;
        const alt = base.slice();
        alt[i] = candidates[j];
        const key = alt.join(',');
        if(!variants.some(v=>v.join(',')===key)) variants.push(alt);
      }
    }

    // Deduplicate variants and cap
    const uniq = [];
    for(const v of variants){
      const k = v.join(',');
      if(!uniq.some(x=>x.join(',')===k)) uniq.push(v.slice(0,MAX_PER_SEM));
      if(uniq.length>=12) break;
    }

    // Explore each variant
    for(const sel of uniq){
      if(results.length >= limit) break;
      const newPlan = Object.assign({}, planObj);
      newPlan[sem] = newPlan[sem] || [];
      const newApproved = new Set(approvedSet);
      // Also add those already in plan to newApproved (so prereqs see them)
      Object.keys(newPlan).forEach(k => (newPlan[k]||[]).forEach(it => newApproved.add(String(it).replace(/\s*\(anual\)$/,''))));

      let placed = 0;
      let ok = true;
      for(const code of sel){
        if(placed >= MAX_PER_SEM) break;
        if(newApproved.has(code)) continue;
        if(isAnnual(code)){
          if(!canPlaceAnnual(newPlan, code, sem, allowedEnd)){
            ok = false; break;
          }
          newPlan[sem].push(code);
          newPlan[sem+1] = newPlan[sem+1] || [];
          newPlan[sem+1].push(code + ' (anual)');
          newApproved.add(code);
          placed++;
        } else {
          if(!canPlaceSingle(newPlan, code, sem)) continue;
          newPlan[sem].push(code);
          newApproved.add(code);
          placed++;
        }
      }
      if(!ok) continue;

      // Greedily fill remaining slots in this sem with other available courses
      let more = allCourses.filter(c => !newApproved.has(c) && canTake(c, Array.from(newApproved)) && (isFreeMovable(c) || !R[c] || R[c].sem <= sem));
      more.sort((a,b)=> dependentsCount(b) - dependentsCount(a) || a.localeCompare(b));
      for(const m of more){
        if(newPlan[sem].length >= MAX_PER_SEM) break;
        if(newApproved.has(m)) continue;
        if(isAnnual(m)){
          if(!canPlaceAnnual(newPlan, m, sem, allowedEnd)) continue;
          newPlan[sem].push(m);
          newPlan[sem+1] = newPlan[sem+1] || [];
          newPlan[sem+1].push(m + ' (anual)');
          newApproved.add(m);
        } else {
          newPlan[sem].push(m);
          newApproved.add(m);
        }
      }

      dfs(sem+1, newApproved, newPlan, allowedEnd);
      if(results.length >= limit) break;
    }

    // Also try skipping placing anything this sem (allow later placements)
    if(results.length < limit){
      const copyPlan = Object.assign({}, planObj);
      copyPlan[sem] = copyPlan[sem] || [];
      dfs(sem+1, new Set(approvedSet), copyPlan, allowedEnd);
    }
  }

  // Try strictly within 8 sem
  dfs(startSem, new Set(initialApproved), {}, startSem + span - 1);
  // If not enough results, allow one extra semester (9th)
  if(results.length < limit){
    dfs(startSem, new Set(initialApproved), {}, startSem + span);
  }

  // If still empty, produce a deterministic greedy fallback that will not exceed 9 sem
  if(results.length === 0){
    const fallback = {};
    const assigned = new Set(initialApproved);
    for(let sem = startSem; sem < startSem + span; sem++){
      fallback[sem] = fallback[sem] || [];
      let candidates = Object.keys(R).filter(c => !assigned.has(c) && canTake(c, Array.from(assigned)) && (isFreeMovable(c) || !R[c] || R[c].sem <= sem));
      candidates.sort((a,b)=> dependentsCount(b) - dependentsCount(a));
      for(const c of candidates){
        if(fallback[sem].length >= MAX_PER_SEM) break;
        if(isAnnual(c) && sem === startSem + span -1) continue;
        if(isAnnual(c)){
          fallback[sem].push(c);
          fallback[sem+1] = fallback[sem+1] || [];
          fallback[sem+1].push(c + ' (anual)');
          assigned.add(c);
        } else {
          fallback[sem].push(c);
          assigned.add(c);
        }
      }
    }
    results.push(fallback);
  }

  // Return up to limit distinct plans
  return results.slice(0, limit);
}

/* Rank plans heuristically */
function rankPlans(plans){
  const scorePlan = (plan) => {
    let score = 0;
    const planSemesters = Object.keys(plan).map(n=>Number(n)).sort((a,b)=>a-b);
    planSemesters.forEach(s => {
      const arr = plan[s] || [];
      score += (arr.length) * 10;
      arr.forEach(c => {
        const code = String(c).replace(/\s*\(anual\)$/,'');
        score += dependentsCount(code) * (100 - s);
      });
    });
    const maxSem = planSemesters.length ? Math.max(...planSemesters) : 0;
    score -= maxSem * 2; // prefer shorter end index
    return score;
  };
  return plans.sort((A,B) => scorePlan(B) - scorePlan(A));
}

/* Render plans and action */
function renderPlans(){
  plansContainer.innerHTML = '';
  const startSemester = startSemesterSel.value || '';
  const rawPlans = generatePlans(approved, PLAN_LIMIT, startSemester);
  if(!rawPlans || rawPlans.length === 0){
    plansContainer.innerHTML = '<p style="color:var(--muted)">No se pudo generar rutas. Marca ramos aprobados o revisa prerrequisitos.</p>';
    updatePlanAction(null);
    return;
  }
  const ranked = rankPlans(rawPlans);

  ranked.forEach((plan, idx) => {
    const card = document.createElement('div'); card.className = 'plan-card';
    const title = document.createElement('div'); title.className = 'plan-title';
    const h = document.createElement('strong'); h.textContent = (idx===0? 'Opción ' + (idx+1) : 'Alternativa ' + (idx+1));
    title.appendChild(h); card.appendChild(title);

    const planSemKeys = Object.keys(plan).map(k=>Number(k)).sort((a,b)=>a-b);
    const pgrid = document.createElement('div'); pgrid.className = 'plan-grid';
    for(const s of planSemKeys){
      const cell = document.createElement('div'); cell.className = 'plan-cell';
      const semIndex = Number(s);
      cell.style.background = semColors[((semIndex-1)%semColors.length + semColors.length) % semColors.length];
      const semTitle = document.createElement('div'); semTitle.style.fontWeight='700'; semTitle.style.marginBottom='6px';
      semTitle.textContent = 'Sem ' + semIndex;
      cell.appendChild(semTitle);
      const arr = plan[s]||[];
      if(arr.length === 0){
        const emptyNote = document.createElement('div'); emptyNote.style.color='var(--muted)'; emptyNote.style.fontSize='12px';
        emptyNote.textContent = '(sin asignar)';
        cell.appendChild(emptyNote);
      } else {
        arr.forEach(c => {
          const pill = document.createElement('div'); pill.className='pill';
          const clean = String(c).replace(/\s*\(anual\)$/,'');
          pill.textContent = clean + (R[clean] ? ' — ' + R[clean].nombre : (c.includes('(anual)') ? ' — (anual)' : ''));
          pill.title = R[clean] ? R[clean].nombre : '';
          cell.appendChild(pill);
        });
      }
      pgrid.appendChild(cell);
    }
    card.appendChild(pgrid);

    const semSel = Number(semActualSel.value);
    const upNext = plan[semSel] || [];
    const subtitle = document.createElement('div'); subtitle.style.marginTop='8px'; subtitle.style.fontWeight='700';
    subtitle.textContent = 'Sugeridos para sem ' + semSel + ' (' + upNext.length + ' ramos)';
    card.appendChild(subtitle);
    const ol = document.createElement('ol');
    if(upNext.length === 0){
      const li = document.createElement('li'); li.textContent = 'No hay ramos sugeridos para este semestre en esta alternativa.'; ol.appendChild(li);
    } else {
      upNext.forEach(c => {
        const clean = String(c).replace(/\s*\(anual\)$/,'');
        const li = document.createElement('li'); li.textContent = clean + (R[clean] ? ' — ' + R[clean].nombre : (c.includes('(anual)') ? ' — (anual)' : ''));
        ol.appendChild(li);
      });
    }
    card.appendChild(ol);

    plansContainer.appendChild(card);
  });

  updatePlanAction(ranked[0]);
}

/* update Plan de Acción */
function updatePlanAction(plan){
  planAction.innerHTML = '';
  const sem = Number(semActualSel.value);
  semLabel.textContent = sem;
  if(!plan || !plan[sem] || plan[sem].length === 0){
    const li = document.createElement('li'); li.textContent = 'No hay ramos sugeridos para este semestre. Considera optativos o recuperar prerrequisitos.'; planAction.appendChild(li);
    return;
  }
  plan[sem].forEach(c => {
    const clean = String(c).replace(/\s*\(anual\)$/,'');
    const li = document.createElement('li'); li.textContent = clean + (R[clean] ? ' — ' + R[clean].nombre : (c.includes('(anual)') ? ' — (anual)' : ''));
    planAction.appendChild(li);
  });
}

/* update UI */
function updateAll(){
  renderMalla();
  renderPlans();
}

/* initial render */
renderMalla();
renderPlans();

/* listeners */
semActualSel.addEventListener('change', () => { updateAll(); });
startSemesterSel.addEventListener('change', () => { updateAll(); });
document.addEventListener('keydown', (e) => {
  if(e.key.toLowerCase()==='r'){ approved = []; updateAll(); }
});
</script>
</body>
</html>
